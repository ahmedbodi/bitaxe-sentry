{% extends "base.html" %}

{% block title %}History - Bitaxe Sentry{% endblock %}
{% block nav_history_active %}active{% endblock %}

{% block head_extra %}
<style>
    .chart-container {
        position: relative;
        height: 300px;
        width: 100%;
    }
    .empty-chart-message {
        display: flex;
        height: 300px;
        align-items: center;
        justify-content: center;
        color: #6c757d;
        font-style: italic;
        background-color: #f8f9fa;
        border-radius: 0.25rem;
    }
    .chart-controls {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 10px;
        gap: 10px;
    }
    .chart-options {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #dee2e6;
    }
    .chart-options .form-check {
        margin-right: 15px;
    }
    .chart-options-group {
        display: flex;
        align-items: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col">
        <div class="d-flex justify-content-between align-items-center">
            <h2>Miner History</h2>
            <div class="form-group">
                <select id="minerSelector" class="form-select" onchange="if(this.value==='') { window.location.href='/history'; } else { window.location.href='/history?miner_id=' + this.value; }">
                    <option value="">All Miners</option>
                    {% for miner in miners %}
                    <option value="{{ miner.id }}" {% if miner.id == selected_miner %}selected{% endif %}>
                        {{ miner.name }}
                    </option>
                    {% endfor %}
                </select>
            </div>
        </div>
        <hr>
    </div>
</div>

{% if not readings_by_miner %}
<div class="alert alert-info" role="alert">
    <h4 class="alert-heading">No history data available!</h4>
    <p>There is no history data available for the selected time period or miner.</p>
    <hr>
    <p class="mb-0">This could be because:</p>
    <ul>
        <li>You haven't selected a miner</li>
        <li>No data has been collected yet</li>
        <li>The selected miner has no data in the last 24 hours</li>
    </ul>
    <p>Wait for more readings to be collected or check your configuration.</p>
</div>
{% else %}

<div class="row mb-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5>Hash Rate (MH/s)</h5>
                <div class="chart-controls">
                    <button class="btn btn-sm btn-outline-secondary" data-hours="1" onclick="updateChartTimeframe(this)">1h</button>
                    <button class="btn btn-sm btn-outline-secondary" data-hours="6" onclick="updateChartTimeframe(this)">6h</button>
                    <button class="btn btn-sm btn-outline-secondary active" data-hours="24" onclick="updateChartTimeframe(this)">24h</button>
                </div>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="hashRateChart"></canvas>
                </div>
                <div class="chart-options">
                    <div class="chart-options-group">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="hashRateCurved" checked onchange="toggleCurvedLines('hashRateChart', this.checked)">
                            <label class="form-check-label" for="hashRateCurved">Curved lines</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="hashRatePoints" checked onchange="toggleDataPoints('hashRateChart', this.checked)">
                            <label class="form-check-label" for="hashRatePoints">Show points</label>
                        </div>
                    </div>
                    <div class="chart-options-group">
                        <label class="me-2">Legend:</label>
                        <select class="form-select form-select-sm" style="width: auto;" onchange="changeLegendPosition('hashRateChart', this.value)">
                            <option value="top">Top</option>
                            <option value="bottom">Bottom</option>
                            <option value="left">Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5>Temperature (°C)</h5>
                <div class="chart-controls">
                    <button class="btn btn-sm btn-outline-secondary" data-hours="1" onclick="updateChartTimeframe(this)">1h</button>
                    <button class="btn btn-sm btn-outline-secondary" data-hours="6" onclick="updateChartTimeframe(this)">6h</button>
                    <button class="btn btn-sm btn-outline-secondary active" data-hours="24" onclick="updateChartTimeframe(this)">24h</button>
                </div>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="tempChart"></canvas>
                </div>
                <div class="chart-options">
                    <div class="chart-options-group">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="tempChartCurved" checked onchange="toggleCurvedLines('tempChart', this.checked)">
                            <label class="form-check-label" for="tempChartCurved">Curved lines</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="tempChartPoints" checked onchange="toggleDataPoints('tempChart', this.checked)">
                            <label class="form-check-label" for="tempChartPoints">Show points</label>
                        </div>
                    </div>
                    <div class="chart-options-group">
                        <label class="me-2">Legend:</label>
                        <select class="form-select form-select-sm" style="width: auto;" onchange="changeLegendPosition('tempChart', this.value)">
                            <option value="top">Top</option>
                            <option value="bottom">Bottom</option>
                            <option value="left">Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5>Voltage (V)</h5>
                <div class="chart-controls">
                    <button class="btn btn-sm btn-outline-secondary" data-hours="1" onclick="updateChartTimeframe(this)">1h</button>
                    <button class="btn btn-sm btn-outline-secondary" data-hours="6" onclick="updateChartTimeframe(this)">6h</button>
                    <button class="btn btn-sm btn-outline-secondary active" data-hours="24" onclick="updateChartTimeframe(this)">24h</button>
                </div>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="voltageChart"></canvas>
                </div>
                <div class="chart-options">
                    <div class="chart-options-group">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="voltageChartCurved" checked onchange="toggleCurvedLines('voltageChart', this.checked)">
                            <label class="form-check-label" for="voltageChartCurved">Curved lines</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="voltageChartPoints" checked onchange="toggleDataPoints('voltageChart', this.checked)">
                            <label class="form-check-label" for="voltageChartPoints">Show points</label>
                        </div>
                    </div>
                    <div class="chart-options-group">
                        <label class="me-2">Legend:</label>
                        <select class="form-select form-select-sm" style="width: auto;" onchange="changeLegendPosition('voltageChart', this.value)">
                            <option value="top">Top</option>
                            <option value="bottom">Bottom</option>
                            <option value="left">Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Store the readings data for JavaScript -->
<script id="readings-data" type="application/json">
{{ readings_by_miner|tojson }}
</script>

<!-- Store the windowed data for JavaScript -->
<script id="windowed-data" type="application/json">
{{ windowed_data|tojson }}
</script>

{% endif %}
{% endblock %}

{% block scripts %}
<script>
    // Global chart references
    let hashRateChart = null;
    let tempChart = null;
    let voltageChart = null;
    
    // Global data storage
    let originalMinerData = null;
    let windowedData = null;
    
    // Parse timestamps to Date objects
    function parseTimestamps(minerData) {
        const parsedData = {};
        
        for (const minerName in minerData) {
            // Just copy the data without any complex timestamp parsing
            parsedData[minerName] = minerData[minerName];
        }
        
        return parsedData;
    }
    
    // Format date for display
    function formatDateTime(timestamp) {
        // Just return the timestamp as is, since it's already in HH:MM:SS format
        return timestamp;
    }
    
    // Update chart timeframe
    function updateChartTimeframe(button) {
        // Update active button state
        const chartCard = button.closest('.card');
        const buttons = chartCard.querySelectorAll('.chart-controls button');
        buttons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        // Get the hours window
        const hoursWindow = parseInt(button.getAttribute('data-hours'), 10);
        
        // Get the chart ID
        const chartContainer = chartCard.querySelector('.chart-container');
        const canvas = chartContainer.querySelector('canvas');
        const chartId = canvas.id;
        
        // Update the chart
        updateChart(chartId, hoursWindow);
    }
    
    // Update a specific chart with new time window
    function updateChart(chartId, hoursWindow) {
        if (!windowedData || !windowedData[hoursWindow]) {
            console.error(`No data available for ${hoursWindow}h window`);
            return;
        }
        
        console.log(`Updating ${chartId} with ${hoursWindow}h window`);
        
        // Use the pre-sliced data for the selected time window
        const filteredData = windowedData[hoursWindow];
        
        // Collect all unique timestamps from all miners
        const allTimestamps = new Set();
        for (const minerName in filteredData) {
            filteredData[minerName].forEach(reading => {
                if (reading.timestamp) {
                    allTimestamps.add(reading.timestamp);
                }
            });
        }
        
        // Convert to array and sort
        const uniqueTimestamps = Array.from(allTimestamps).sort();
        
        console.log(`Found ${uniqueTimestamps.length} unique timestamps for ${hoursWindow}h window`);
        if (uniqueTimestamps.length > 0) {
            console.log(`Time range: ${uniqueTimestamps[0]} to ${uniqueTimestamps[uniqueTimestamps.length - 1]}`);
        }
        
        // Format timestamps for display
        const displayLabels = uniqueTimestamps.map(timestamp => formatDateTime(timestamp));
        
        // Prepare datasets
        const datasets = [];
        for (const minerName in filteredData) {
            const color = getColorForMiner(minerName);
            const data = filteredData[minerName];
            
            console.log(`Processing miner ${minerName} with ${data.length} readings for ${hoursWindow}h window`);
            
            // Map readings to timestamps
            const readingsByTimestamp = {};
            data.forEach(reading => {
                if (reading.timestamp) {
                    readingsByTimestamp[reading.timestamp] = reading;
                }
            });
            
            // Get the appropriate data values based on chart type
            const dataValues = [];
            uniqueTimestamps.forEach(timestamp => {
                const reading = readingsByTimestamp[timestamp];
                
                if (chartId === 'hashRateChart') {
                    dataValues.push(reading ? reading.hash_rate : null);
                } else if (chartId === 'tempChart') {
                    dataValues.push(reading ? reading.temperature : null);
                } else if (chartId === 'voltageChart') {
                    dataValues.push(reading ? reading.voltage : null);
                }
            });
            
            // Get chart settings
            const chartElement = document.getElementById(chartId);
            const card = chartElement.closest('.card');
            const curvedCheckbox = card.querySelector('input[type="checkbox"][id$="Curved"]');
            const pointsCheckbox = card.querySelector('input[type="checkbox"][id$="Points"]');
            
            const tension = curvedCheckbox && curvedCheckbox.checked ? 0.4 : 0;
            const pointRadius = pointsCheckbox && pointsCheckbox.checked ? 3 : 0;
            
            datasets.push({
                label: minerName,
                data: dataValues,
                backgroundColor: color,
                borderColor: color,
                borderWidth: 2,
                fill: false,
                tension: tension,
                pointRadius: pointRadius,
                pointHoverRadius: 5,
                spanGaps: true,  // Connect lines across gaps (null values)
                showLine: true   // Always show lines between points
            });
        }
        
        // Update the chart
        let chart;
        if (chartId === 'hashRateChart') {
            chart = hashRateChart;
        } else if (chartId === 'tempChart') {
            chart = tempChart;
        } else if (chartId === 'voltageChart') {
            chart = voltageChart;
        }
        
        if (chart) {
            chart.data.labels = displayLabels;
            chart.data.datasets = datasets;
            chart.update({
                duration: 300,
                easing: 'easeOutQuad'
            });
            
            console.log(`Updated ${chartId} with ${displayLabels.length} labels and ${datasets.length} datasets`);
        }
    }
    
    // Toggle curved lines for a chart
    function toggleCurvedLines(chartId, curved) {
        const chart = getChartById(chartId);
        if (!chart) return;
        
        chart.data.datasets.forEach(dataset => {
            dataset.tension = curved ? 0.4 : 0;
        });
        
        chart.update({
            duration: 300,
            easing: 'easeOutQuad'
        });
    }
    
    // Toggle data points for a chart
    function toggleDataPoints(chartId, showPoints) {
        const chart = getChartById(chartId);
        if (!chart) return;
        
        chart.data.datasets.forEach(dataset => {
            dataset.pointRadius = showPoints ? 3 : 0;
        });
        
        chart.update({
            duration: 300,
            easing: 'easeOutQuad'
        });
    }
    
    // Change legend position for a chart
    function changeLegendPosition(chartId, position) {
        const chart = getChartById(chartId);
        if (!chart) return;
        
        chart.options.plugins.legend.position = position;
        chart.update({
            duration: 300,
            easing: 'easeOutQuad'
        });
    }
    
    // Helper to get chart by ID
    function getChartById(chartId) {
        if (chartId === 'hashRateChart') return hashRateChart;
        if (chartId === 'tempChart') return tempChart;
        if (chartId === 'voltageChart') return voltageChart;
        return null;
    }
    
    // Get a consistent color for a miner name
    function getColorForMiner(minerName) {
        // Predefined color palette with distinct colors
        const colorPalette = [
            '#4285F4', // Google Blue
            '#EA4335', // Google Red
            '#FBBC05', // Google Yellow
            '#34A853', // Google Green
            '#FF9900', // Orange
            '#9C27B0', // Purple
            '#00ACC1', // Cyan
            '#FF5722', // Deep Orange
            '#3F51B5', // Indigo
            '#8BC34A', // Light Green
            '#795548', // Brown
            '#607D8B', // Blue Grey
            '#E91E63', // Pink
            '#673AB7', // Deep Purple
            '#009688', // Teal
            '#FFC107', // Amber
            '#03A9F4', // Light Blue
            '#CDDC39', // Lime
            '#FF5252', // Red Accent
            '#2196F3'  // Blue
        ];
        
        // Static map to store assigned colors
        if (!window.minerColorMap) {
            window.minerColorMap = {};
        }
        
        // If this miner already has an assigned color, return it
        if (window.minerColorMap[minerName]) {
            return window.minerColorMap[minerName];
        }
        
        // Find all currently used colors
        const usedColors = Object.values(window.minerColorMap);
        
        // Find the first unused color
        let selectedColor = null;
        for (const color of colorPalette) {
            if (!usedColors.includes(color)) {
                selectedColor = color;
                break;
            }
        }
        
        // If all colors are used, use a hash-based approach as fallback
        if (!selectedColor) {
            let hash = 0;
            for (let i = 0; i < minerName.length; i++) {
                hash = minerName.charCodeAt(i) + ((hash << 5) - hash);
            }
            const index = Math.abs(hash) % colorPalette.length;
            selectedColor = colorPalette[index];
        }
        
        // Store the color for this miner
        window.minerColorMap[minerName] = selectedColor;
        
        return selectedColor;
    }
    
    // Initialize all charts
    function initCharts(minerData) {
        // Common chart options
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 500
            },
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                tooltip: {
                    enabled: true
                },
                legend: {
                    position: 'top'
                }
            },
            scales: {
                x: {
                    ticks: {
                        maxRotation: 45,
                        minRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 20
                    }
                }
            },
            elements: {
                line: {
                    tension: 0.4,
                    borderWidth: 2,
                    fill: false
                },
                point: {
                    radius: 3,
                    hoverRadius: 5
                }
            }
        };
        
        // Initialize Hash Rate chart
        const hashRateCtx = document.getElementById('hashRateChart');
        if (hashRateCtx) {
            hashRateChart = new Chart(hashRateCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'MH/s'
                            }
                        }
                    },
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} MH/s`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize Temperature chart
        const tempCtx = document.getElementById('tempChart');
        if (tempCtx) {
            tempChart = new Chart(tempCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            title: {
                                display: true,
                                text: '°C'
                            }
                        }
                    },
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} °C`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize Voltage chart
        const voltageCtx = document.getElementById('voltageChart');
        if (voltageCtx) {
            voltageChart = new Chart(voltageCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            title: {
                                display: true,
                                text: 'V'
                            }
                        }
                    },
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} V`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update all charts with 24h window initially
        updateChart('hashRateChart', 24);
        updateChart('tempChart', 24);
        updateChart('voltageChart', 24);
    }
    
    // Auto-refresh the charts every 60 seconds
    function setupAutoRefresh() {
        setInterval(() => {
            // Get current time window from active buttons
            const hashRateHours = parseInt(document.querySelector('#hashRateChart').closest('.card').querySelector('.chart-controls .active').getAttribute('data-hours'), 10);
            const tempHours = parseInt(document.querySelector('#tempChart').closest('.card').querySelector('.chart-controls .active').getAttribute('data-hours'), 10);
            const voltageHours = parseInt(document.querySelector('#voltageChart').closest('.card').querySelector('.chart-controls .active').getAttribute('data-hours'), 10);
            
            console.log(`Auto-refreshing charts with windows: Hash Rate=${hashRateHours}h, Temp=${tempHours}h, Voltage=${voltageHours}h`);
            
            // Reload the data
            fetch(window.location.href)
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const dataElement = doc.getElementById('readings-data');
                    const windowedDataElement = doc.getElementById('windowed-data');
                    
                    if (dataElement && windowedDataElement) {
                        try {
                            const newMinerData = JSON.parse(dataElement.textContent.trim());
                            originalMinerData = parseTimestamps(newMinerData);
                            
                            const newWindowedData = JSON.parse(windowedDataElement.textContent.trim());
                            windowedData = newWindowedData;
                            
                            console.log(`Data refreshed at ${new Date().toLocaleTimeString()}`);
                            
                            // Update charts with their current time windows
                            updateChart('hashRateChart', hashRateHours);
                            updateChart('tempChart', tempHours);
                            updateChart('voltageChart', voltageHours);
                        } catch (e) {
                            console.error("Error processing refreshed data:", e);
                        }
                    } else {
                        console.error("Could not find data elements in refreshed page");
                    }
                })
                .catch(error => console.error('Error refreshing data:', error));
        }, 60000); // Refresh every 60 seconds
    }
    
    // Main initialization
    document.addEventListener('DOMContentLoaded', function() {
        // Get the data elements with JSON contents
        const dataElement = document.getElementById('readings-data');
        const windowedDataElement = document.getElementById('windowed-data');
        
        // Only proceed if we have data
        if (dataElement && windowedDataElement) {
            try {
                const minerData = JSON.parse(dataElement.textContent.trim());
                windowedData = JSON.parse(windowedDataElement.textContent.trim());
                
                console.log("Parsed data:", minerData);
                console.log("Windowed data:", windowedData);
                
                // Check if we actually have data points
                let hasData = false;
                for (const minerName in minerData) {
                    if (minerData[minerName] && minerData[minerName].length > 0) {
                        hasData = true;
                        break;
                    }
                }
                
                if (!hasData || Object.keys(minerData).length === 0) {
                    console.log("No data points found");
                    // Replace chart canvases with "No data" messages
                    document.querySelectorAll('.chart-container').forEach(container => {
                        const canvas = container.querySelector('canvas');
                        if (canvas) {
                            canvas.remove();
                            container.innerHTML = '<div class="empty-chart-message">No data points available to display</div>';
                        }
                    });
                } else {
                    // Parse timestamps and store globally
                    originalMinerData = parseTimestamps(minerData);
                    
                    // Initialize charts
                    initCharts(originalMinerData);
                    
                    // Setup auto-refresh
                    setupAutoRefresh();
                }
            } catch (e) {
                console.error("Error parsing data:", e);
            }
        }
    });
</script>
{% endblock %} 